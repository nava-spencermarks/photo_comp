{% extends "base.html" %}

{% block content %}
<div class="card">
    <form method="POST" action="{{ url_for('compare_faces') }}" enctype="multipart/form-data">
        <div class="image-container">
            <div class="image-box">
                <h3>First Image</h3>
                <div class="upload-area">
                    <div class="form-group">
                        <label for="image1">Choose first image:</label>
                        <input type="file" id="image1" name="image1" class="file-input" 
                               accept="image/*" required>
                    </div>
                    <p style="color: #666; font-size: 0.9rem;">
                        Supported formats: PNG, JPG, JPEG, GIF, BMP
                    </p>
                </div>
                <div class="image-canvas-container" id="canvas-container-1" style="display: none;">
                    <div style="position: relative;">
                        <img id="preview1" style="max-width: 300px; max-height: 300px; border-radius: 6px;">
                        <canvas id="canvas1" style="position: absolute; top: 0; left: 0; cursor: crosshair;"></canvas>
                    </div>
                    <div class="canvas-controls">
                        <button type="button" class="btn-small" onclick="clearMasks('canvas1')" style="background: #f44336;">üóëÔ∏è Clear All</button>
                        <div style="font-size: 0.8rem; color: #666; margin-top: 0.5rem;">
                            <div>Draw rectangles to mask facial features</div>
                            <div style="margin-top: 0.3rem; font-size: 0.7rem; color: #888;">
                                Click empty area to create new rectangle ‚Ä¢ Click rectangle to select/delete
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="image-box">
                <h3>Second Image</h3>
                <div class="upload-area">
                    <div class="form-group">
                        <label for="image2">Choose second image:</label>
                        <input type="file" id="image2" name="image2" class="file-input" 
                               accept="image/*" required>
                    </div>
                    <p style="color: #666; font-size: 0.9rem;">
                        Supported formats: PNG, JPG, JPEG, GIF, BMP
                    </p>
                </div>
                <div class="image-canvas-container" id="canvas-container-2" style="display: none;">
                    <div style="position: relative;">
                        <img id="preview2" style="max-width: 300px; max-height: 300px; border-radius: 6px;">
                        <canvas id="canvas2" style="position: absolute; top: 0; left: 0; cursor: crosshair;"></canvas>
                    </div>
                    <div class="canvas-controls">
                        <button type="button" class="btn-small" onclick="clearMasks('canvas2')" style="background: #f44336;">üóëÔ∏è Clear All</button>
                        <div style="font-size: 0.8rem; color: #666; margin-top: 0.5rem;">
                            <div>Draw rectangles to mask facial features</div>
                            <div style="margin-top: 0.3rem; font-size: 0.7rem; color: #888;">
                                Click empty area to create new rectangle ‚Ä¢ Click rectangle to select/delete
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div style="text-align: center; margin-top: 2rem;">
            <button type="submit" class="btn">
                üîç Compare Faces
            </button>
        </div>
    </form>
</div>

<div class="card">
    <h3 style="margin-bottom: 1rem; color: #555;">How it works:</h3>
    <ol style="color: #666; line-height: 1.6;">
        <li>Upload two images containing faces</li>
        <li>Our AI analyzes the facial features in both images</li>
        <li>Get instant results showing if it's the same person</li>
        <li>View detailed comparison metrics</li>
    </ol>
</div>

<script>
// Post-it note style masking system for adjudicators
class FaceMasker {
    constructor(canvasId, imageId) {
        this.canvas = document.getElementById(canvasId);
        this.image = document.getElementById(imageId);
        this.ctx = this.canvas.getContext('2d');
        this.rectangles = [];
        this.isDrawing = false;
        this.startX = 0;
        this.startY = 0;
        this.selectedRect = null;
        this.hoveredRect = null;
        
        this.setupEventListeners();
    }
    
    setupEventListeners() {
        this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
    }
    
    updateCanvasSize() {
        this.canvas.width = this.image.offsetWidth;
        this.canvas.height = this.image.offsetHeight;
        this.canvas.style.width = this.image.offsetWidth + 'px';
        this.canvas.style.height = this.image.offsetHeight + 'px';
        this.redraw();
    }
    
    getMousePos(e) {
        const rect = this.canvas.getBoundingClientRect();
        return {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
        };
    }
    
    findRectangleAt(x, y) {
        // Check from top to bottom (last drawn first)
        for (let i = this.rectangles.length - 1; i >= 0; i--) {
            const rect = this.rectangles[i];
            if (x >= rect.x && x <= rect.x + rect.width && 
                y >= rect.y && y <= rect.y + rect.height) {
                return rect;
            }
        }
        return null;
    }
    
    handleMouseDown(e) {
        e.preventDefault();
        const pos = this.getMousePos(e);
        
        const clickedRect = this.findRectangleAt(pos.x, pos.y);
        
        if (clickedRect) {
            // Click on existing rectangle - select it
            this.selectedRect = clickedRect;
            this.redraw();
        } else {
            // Click on empty area - start drawing new rectangle
            this.isDrawing = true;
            this.startX = pos.x;
            this.startY = pos.y;
            this.selectedRect = null;
        }
    }
    
    handleMouseMove(e) {
        const pos = this.getMousePos(e);
        
        if (this.isDrawing) {
            // Drawing new rectangle
            this.drawPreview(pos.x, pos.y);
        } else {
            // Update hover state
            const newHovered = this.findRectangleAt(pos.x, pos.y);
            if (newHovered !== this.hoveredRect) {
                this.hoveredRect = newHovered;
                this.canvas.style.cursor = newHovered ? 'pointer' : 'crosshair';
                this.redraw();
            }
        }
    }
    
    handleMouseUp(e) {
        if (!this.isDrawing) return;
        
        const pos = this.getMousePos(e);
        const width = pos.x - this.startX;
        const height = pos.y - this.startY;
        
        // Only create rectangle if it's reasonably sized (10px minimum)
        if (Math.abs(width) >= 10 && Math.abs(height) >= 10) {
            const newRect = {
                x: Math.min(this.startX, pos.x),
                y: Math.min(this.startY, pos.y),
                width: Math.abs(width),
                height: Math.abs(height)
            };
            this.rectangles.push(newRect);
            this.selectedRect = newRect;
            this.syncRectangles();
        }
        
        this.isDrawing = false;
        this.redraw();
    }
    
    drawPreview(mouseX, mouseY) {
        this.redraw();
        
        const width = mouseX - this.startX;
        const height = mouseY - this.startY;
        
        // Draw preview rectangle
        this.ctx.globalAlpha = 0.5;
        this.ctx.fillStyle = '#ffeb3b';
        this.ctx.fillRect(this.startX, this.startY, width, height);
        this.ctx.strokeStyle = '#ff9800';
        this.ctx.lineWidth = 2;
        this.ctx.strokeRect(this.startX, this.startY, width, height);
        this.ctx.globalAlpha = 1.0;
        
        // Sync preview to other canvas
        this.syncPreview(width, height);
    }
    
    redraw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.rectangles.forEach((rect, index) => {
            const isSelected = rect === this.selectedRect;
            const isHovered = rect === this.hoveredRect;
            
            // Draw rectangle (post-it note style)
            this.ctx.globalAlpha = 0.8;
            if (isSelected) {
                this.ctx.fillStyle = '#ff5722'; // Orange-red for selected
            } else if (isHovered) {
                this.ctx.fillStyle = '#ff9800'; // Orange for hovered
            } else {
                this.ctx.fillStyle = '#ffeb3b'; // Yellow for normal
            }
            this.ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
            
            // Draw border
            this.ctx.strokeStyle = isSelected ? '#d32f2f' : '#ff9800';
            this.ctx.lineWidth = isSelected ? 3 : 2;
            this.ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
            
            // Draw number
            this.ctx.globalAlpha = 1.0;
            this.ctx.font = 'bold 16px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.fillStyle = '#333333';
            
            const centerX = rect.x + rect.width / 2;
            const centerY = rect.y + rect.height / 2;
            const text = (index + 1).toString();
            
            this.ctx.fillText(text, centerX, centerY);
        });
    }
    
    syncRectangles() {
        const otherMasker = this.canvas.id === 'canvas1' ? canvas2_masker : canvas1_masker;
        
        if (otherMasker && otherMasker.canvas.width > 0 && otherMasker.canvas.height > 0) {
            const scaleX = otherMasker.canvas.width / this.canvas.width;
            const scaleY = otherMasker.canvas.height / this.canvas.height;
            
            otherMasker.rectangles = this.rectangles.map(rect => ({
                x: rect.x * scaleX,
                y: rect.y * scaleY,
                width: rect.width * scaleX,
                height: rect.height * scaleY
            }));
            
            otherMasker.redraw();
        }
    }
    
    syncPreview(width, height) {
        const otherMasker = this.canvas.id === 'canvas1' ? canvas2_masker : canvas1_masker;
        
        if (otherMasker && otherMasker.canvas.width > 0 && otherMasker.canvas.height > 0) {
            const scaleX = otherMasker.canvas.width / this.canvas.width;
            const scaleY = otherMasker.canvas.height / this.canvas.height;
            
            otherMasker.redraw();
            
            const scaledX = this.startX * scaleX;
            const scaledY = this.startY * scaleY;
            const scaledWidth = width * scaleX;
            const scaledHeight = height * scaleY;
            
            otherMasker.ctx.globalAlpha = 0.5;
            otherMasker.ctx.fillStyle = '#ffeb3b';
            otherMasker.ctx.fillRect(scaledX, scaledY, scaledWidth, scaledHeight);
            otherMasker.ctx.strokeStyle = '#ff9800';
            otherMasker.ctx.lineWidth = 2;
            otherMasker.ctx.strokeRect(scaledX, scaledY, scaledWidth, scaledHeight);
            otherMasker.ctx.globalAlpha = 1.0;
        }
    }
    
    deleteSelected() {
        if (this.selectedRect) {
            const index = this.rectangles.indexOf(this.selectedRect);
            if (index > -1) {
                this.rectangles.splice(index, 1);
                this.selectedRect = null;
                this.syncRectangles();
                this.redraw();
            }
        }
    }
    
    clearAll() {
        this.rectangles = [];
        this.selectedRect = null;
        this.hoveredRect = null;
        this.redraw();
        this.syncRectangles();
    }
    
    getRectangleData() {
        return this.rectangles.map(rect => ({
            x: rect.x / this.canvas.width,
            y: rect.y / this.canvas.height,
            width: rect.width / this.canvas.width,
            height: rect.height / this.canvas.height
        }));
    }
}

// Global variables
let canvas1_masker, canvas2_masker;

// Add keyboard support for deleting selected rectangles
document.addEventListener('keydown', function(e) {
    if (e.key === 'Delete' || e.key === 'Backspace') {
        if (canvas1_masker && canvas1_masker.selectedRect) {
            canvas1_masker.deleteSelected();
        }
        if (canvas2_masker && canvas2_masker.selectedRect) {
            canvas2_masker.deleteSelected();
        }
    }
});

// Image preview with masking
document.getElementById('image1').addEventListener('change', function(e) {
    previewImage(e.target, 'preview1', 'canvas1', 'canvas-container-1');
});

document.getElementById('image2').addEventListener('change', function(e) {
    previewImage(e.target, 'preview2', 'canvas2', 'canvas-container-2');
});

function previewImage(input, previewId, canvasId, containerId) {
    if (input.files && input.files[0]) {
        const reader = new FileReader();
        reader.onload = function(e) {
            const preview = document.getElementById(previewId);
            const container = document.getElementById(containerId);
            
            preview.src = e.target.result;
            preview.onload = function() {
                container.style.display = 'block';
                
                // Initialize masker
                if (canvasId === 'canvas1') {
                    canvas1_masker = new FaceMasker(canvasId, previewId);
                } else {
                    canvas2_masker = new FaceMasker(canvasId, previewId);
                }
                
                // Update canvas size
                setTimeout(() => {
                    if (canvasId === 'canvas1') {
                        canvas1_masker.updateCanvasSize();
                    } else {
                        canvas2_masker.updateCanvasSize();
                    }
                }, 100);
            };
        };
        reader.readAsDataURL(input.files[0]);
    }
}

function clearMasks(canvasId) {
    if (canvasId === 'canvas1' && canvas1_masker) {
        canvas1_masker.clearAll();
    } else if (canvasId === 'canvas2' && canvas2_masker) {
        canvas2_masker.clearAll();
    }
}

// Form submission with rectangle data
document.querySelector('form').addEventListener('submit', function(e) {
    if (canvas1_masker && canvas2_masker) {
        const rect1Data = JSON.stringify(canvas1_masker.getRectangleData());
        const rect2Data = JSON.stringify(canvas2_masker.getRectangleData());
        
        const input1 = document.createElement('input');
        input1.type = 'hidden';
        input1.name = 'rectangles1';
        input1.value = rect1Data;
        this.appendChild(input1);
        
        const input2 = document.createElement('input');
        input2.type = 'hidden';
        input2.name = 'rectangles2';
        input2.value = rect2Data;
        this.appendChild(input2);
    }
});
</script>
{% endblock %}